package com.huiju.weixin.WeixinServer.service;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutorService;

import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.alibaba.fastjson.JSONObject;
import com.huiju.weixin.WeixinServer.bean.UserLockKeyBean;
import com.huiju.weixin.WeixinServer.mapper.KeyTbMapper;
import com.huiju.weixin.WeixinServer.mapper.LockKeyTbMapper;
import com.huiju.weixin.WeixinServer.mapper.LockTbMapper;
import com.huiju.weixin.WeixinServer.model.KeyTb;
import com.huiju.weixin.WeixinServer.model.LockKeyTb;
import com.huiju.weixin.WeixinServer.model.LockTb;
import com.huiju.weixin.WeixinServer.util.BleDeviceAuth;
import com.huiju.weixin.WeixinServer.util.CreateExecutorService;
import com.huiju.weixin.WeixinServer.util.GetBleDeviceQrcode;
import com.huiju.weixin.WeixinServer.util.ImportDataToExcel;

import jxl.write.WriteException;
import me.chanjar.weixin.common.exception.WxErrorException;

/**
 * 处理锁和钥匙关系的业务类
 * 
 * @author rencf 2016年11月10日10:57:15
 */
@Service
public class LockKeyService {
	Logger logger = Logger.getLogger(LockKeyService.class);
	@Autowired
	private LockKeyTbMapper lockKeyTbMapper;
	@Autowired
	private KeyTbMapper keyTbMapper;
	@Autowired
	private LockTbMapper lockTbMapper;
	
	@Autowired
	private BleDeviceAuth bleDeviceAuth;
	@Autowired
	private GetBleDeviceQrcode getBleDeviceQrcode;
	
	// 解绑钥匙
	@Transactional
	public int unbindKey(String lockId, String keyId) {
		Map<String,Object> map = new HashMap<String,Object>();
		map.put("lockId", lockId);
		map.put("keyId", keyId);
		return lockKeyTbMapper.deleteByLockIdAndKeyId(map);
	}
	// 添加钥匙
	@Transactional
	public int addKey(LockKeyTb lockKeyTb){
		lockKeyTb.preInsert();
		return lockKeyTbMapper.insert(lockKeyTb);
	}
	// 根据 活码值ticketID获取钥匙列表
	public KeyTb getKeyByTicketId(String ticketId){
		KeyTb keyTb = keyTbMapper.getByTicketId(ticketId);
		return keyTb==null?new KeyTb():keyTb;
	}
	// 根据keyID获取钥匙
	public KeyTb getKeyByKeyId(String keyId){
		KeyTb keyTb = keyTbMapper.getKeyTbByKeyId(keyId);
		return keyTb==null?new KeyTb():keyTb;
	}
	/** 根据lockId 获取钥匙列表
	 * 
	 * @param lockId
	 * @param manage  是否是管理钥匙    0普通钥匙  1 蓝牙钥匙
	 * @return
	 */
	public List<KeyTb> findKeyListByLockId(String lockId,Integer manage){
		Map<String,Object> map = new HashMap<String,Object>();
		map.put("lockId", lockId);
		//map.put("manage", manage); 
		List<KeyTb> keyTbs = lockKeyTbMapper.findKeyTablesByLockId(map);
		return keyTbs==null?new ArrayList<KeyTb>():keyTbs;
	}
	// 修改钥匙
	@Transactional
	public int updateKey(KeyTb keyTb){
		return keyTbMapper.updateByPrimaryKey(keyTb);
	}
	
	/**
	 * 根据设备ID获取钥匙
	 * @param deviceId
	 * @return
	 */
	public UserLockKeyBean getKeyByDeviceId(String deviceId) {
		UserLockKeyBean key =  lockKeyTbMapper.getByDeviceId(deviceId);
		return key==null?new UserLockKeyBean():key;
	}
	/**保存表关系
	 * 
	 * @param key
	 */
	@Transactional
	public void save(LockKeyTb key) {
		lockKeyTbMapper.insert(key);
	}
	
	/**
	 * 
	 * @param key
	 * @param lockkey
	 * @return
	 */
	@Transactional
	public void addkey(KeyTb key, LockKeyTb lockkey) {
		key.preInsert();
		keyTbMapper.updateByPrimaryKey(key);
		lockkey.preInsert();
		lockKeyTbMapper.insert(lockkey);
	}
	
	/**
	 * 删除钥匙
	 * @param lockId
	 * @param keyId
	 */
	@Transactional
	public void deleteKey(String lockId, String keyId) {
		Map<String,Object> map = new HashMap<String,Object>();
		map.put("lockId", lockId);
		map.put("keyId", keyId);
		lockKeyTbMapper.deleteByLockIdAndKeyId(map);
	}
	
	/**
	 * 根据keyId 获取key_tb记录
	 * @param keyId
	 * @return  
	 */
	public KeyTb getKeyTbByKeyId(String keyId) {
		 
		return keyTbMapper.getKeyTbByKeyId(keyId);
	}
	
	public List<Object> findLocksbydeviceId(String deviceId){
		Map<String,Object> map = new HashMap<String,Object>();
		map.put("deviceId", deviceId);
		List<Object> list =  lockKeyTbMapper.findLocksbydeviceId(map);
		return list;
	}
	
	/**
	 * 设备授权 并持久话锁芯，钥匙 ，以及锁芯和钥匙关系
	 * 
	 * @return
	 */
	boolean isok = false;
	public boolean deviceAuth(JSONObject jsonObject) {
		ExecutorService cacheThreadPool = CreateExecutorService.getThreadPool();
		KeyTb key = keyTbMapper.getByQrcodeSerial(jsonObject.getString("qrcodeSerial"));
		if (key == null) {
			return false;
		}
		final String mac = jsonObject.getString("mac");
		final String deviceId = key.getDeviceId();
		key.setCreator(jsonObject.getString("readId"));
		key.setKeyId(jsonObject.getString("keyId"));
		key.setType(1);
		key.setPosition(Integer.parseInt(jsonObject.getString("position")));
		key.setState("1");
		//key.setToothCode(jsonObject.getString("toothCode"));
		key.setVersion(jsonObject.getString("keyVersion"));
		key.setBindTime(new Date());
		LockTb lock = new LockTb();
		lock.setLockId(jsonObject.getString("lockId"));
		lock.setCreator(jsonObject.getString("readId"));
		lock.setVersion(jsonObject.getString("lockVersion"));
		cacheThreadPool.execute(new Runnable() {
			public void run() {
				isok = saveLockAndKey(lock, key);
			}
		});
		cacheThreadPool.execute(new Runnable() {
			public void run() {
				try {
					bleDeviceAuth.bleDeviceAuth(deviceId, mac);
				} catch (IOException | WxErrorException e) {
					logger.error("蓝牙钥匙修改修改失败:" + e.getMessage());
				}
			}
		});
		isok = true;
		return isok;
	}
	/**
	 * 新增锁芯信息  以及修改钥匙信息  并且新增锁芯和钥匙的关系
	 * @param lock
	 * @param key
	 */
	@Transactional
	private  boolean saveLockAndKey(LockTb lock,KeyTb key){
		int j = keyTbMapper.updateByPrimaryKey(key);
		lock.preInsert();
		int k = lockTbMapper.insert(lock);
		LockKeyTb userLock = new LockKeyTb();
		userLock.preInsert();
		userLock.setKeyId(key.getKeyId());
		userLock.setLockId(lock.getLockId());
		int i = lockKeyTbMapper.insert(userLock );
		if(i==1&&j==1&&k==1){
			return true;
		}
		return false;
	}
	
	/**
	 * 授权蓝牙设备并获取设备id和二维码 封装到list中，
	 * @param num  获取设备的个数
	 * @param productId 设备管理中添加的产品id
	 * @return list 
	 * @throws IOException
	 * @throws WxErrorException
	 */
	private List<KeyTb> getDeviceIdAndQrcode(int num,String productId) throws IOException, WxErrorException{
		List<KeyTb> list = new ArrayList<KeyTb>();
		for (int i = 0; i < num; i++) {
			KeyTb key = new KeyTb();
			JSONObject jsonObject = getBleDeviceQrcode.getBleDeviceQrcode(productId);
			key.setDeviceId(jsonObject.getString("deviceid"));
			key.setQrcodeSerial(i+1+"");
			key.setTicketId(jsonObject.getString("qrticket"));
			list.add(key);
		}
		return list;
	}
	
	/**
	 * 授权蓝牙设备并获取设备id和二维码  并将设备id和 二维码 序列号写入到Excel表中以及数据库表中
	 * @param num
	 * @param productId
	 * @throws WxErrorException 
	 * @throws IOException 
	 */
	public void saveDeviceIdAndQrcode(int num,String productId,final String xlsPath) throws IOException, WxErrorException{
		final List<KeyTb> list = getDeviceIdAndQrcode(num, productId);
		ExecutorService cacheThreadPool = CreateExecutorService.getThreadPool();
		//持久化
		cacheThreadPool.execute(new Runnable() {
			public void run() {
				insertKey(list);
			}
		});
		//写入到Excel中
		cacheThreadPool.execute(new Runnable() {
			public void run() {
					try {
						ImportDataToExcel.execute(list,xlsPath);
					} catch (WriteException | IOException e) {
						e.printStackTrace();
					}
			}
		});
		
	}
	
	@Transactional
	private int insertKey(List<KeyTb> keyList){
		int result = 0;
		for (int i = 0; i < keyList.size(); i++) {
			keyTbMapper.insert(keyList.get(i));
		} 
		if(result==keyList.size()){
			return result;
		}
		return 0;
	}
	
}
