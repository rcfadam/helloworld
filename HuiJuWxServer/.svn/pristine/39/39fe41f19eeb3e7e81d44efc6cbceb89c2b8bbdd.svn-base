package com.huiju.weixin.WeixinServer.controller;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.apache.commons.io.IOUtils;
import org.apache.log4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.util.CollectionUtils;
import org.springframework.util.ResourceUtils;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.alibaba.fastjson.JSONObject;
import com.huiju.weixin.WeixinServer.bean.ResponseCode;
import com.huiju.weixin.WeixinServer.bean.RestResponse;
import com.huiju.weixin.WeixinServer.bean.UserLockKeyBean;
import com.huiju.weixin.WeixinServer.bean.WxMpDeviceJsonMessage;
import com.huiju.weixin.WeixinServer.conf.StartupConfig;
import com.huiju.weixin.WeixinServer.model.KeyTb;
import com.huiju.weixin.WeixinServer.model.LockKeyTb;
import com.huiju.weixin.WeixinServer.model.LockTb;
import com.huiju.weixin.WeixinServer.model.UserLockTb;
import com.huiju.weixin.WeixinServer.model.UserTb;
import com.huiju.weixin.WeixinServer.service.LockKeyService;
import com.huiju.weixin.WeixinServer.service.UserLockService;
import com.huiju.weixin.WeixinServer.service.UserService;
import com.huiju.weixin.WeixinServer.util.GetDateUtils;

import me.chanjar.weixin.common.bean.WxJsapiSignature;
import me.chanjar.weixin.common.bean.result.WxMediaUploadResult;
import me.chanjar.weixin.common.exception.WxErrorException;
import me.chanjar.weixin.common.util.StringUtils;
import me.chanjar.weixin.mp.api.WxMpService;
import me.chanjar.weixin.mp.bean.WxMpXmlMessage;
import me.chanjar.weixin.mp.bean.WxMpXmlOutImageMessage;
import me.chanjar.weixin.mp.bean.WxMpXmlOutMessage;
import me.chanjar.weixin.mp.bean.result.WxMpOAuth2AccessToken;
import me.chanjar.weixin.mp.util.json.WxMpGsonBuilder;

@Controller
public class BusinessController {
	private static final Logger logger = Logger.getLogger(BusinessController.class);
	
	@Autowired
	private StartupConfig startupConfig;
	
	@Autowired
	private UserLockService userLockService;

	@Autowired
	private LockKeyService lockKeyService;

	@Autowired
	private UserService userService;
	

	@RequestMapping("/")
	@ResponseBody
	public void handleAll(HttpServletRequest request,HttpServletResponse response) throws IOException, WxErrorException {
		    WxMpService wxMpService = startupConfig.getWxMpService();
			String signature = request.getParameter("signature");
		    String nonce = request.getParameter("nonce");
		    String timestamp = request.getParameter("timestamp");
		    String echostr = request.getParameter("echostr");
		    if (!wxMpService.checkSignature(timestamp, nonce, signature)) {
		      // 消息签名不正确，说明不是公众平台发过来的消息
		    	logger.info("check false.");
		      return;
		    }
		    if (StringUtils.isNotBlank(echostr)) {
		      // 说明是一个仅仅用来验证的请求，回显echostr
		    	logger.info("check true.");
		      return;
		    }
		    String encryptType = StringUtils.isBlank(request.getParameter("encrypt_type")) ?
		            "raw" :request.getParameter("encrypt_type");
		        if ("raw".equals(encryptType)) {
		            this.WxRawMessage(request, response);
		            return;
		        }
		        if ("aes".equals(encryptType)) {
		          //是aes加密的消息
		          //String msgSignature = request.getParameter("msg_signature");
		          //WxMpXmlMessage inMessage = WxMpXmlMessage.fromEncryptedXml(request.getInputStream(), wxMpConfigStorage, timestamp, nonce, msgSignature);
		          //WxMpXmlOutMessage outMessage = wxMpMessageRouter.route(inMessage);
		         //response.getWriter().write(outMessage.toEncryptedXml(wxMpConfigStorage));
		          return;
		        }
		        response.getWriter().println("不可识别的加密类型");
		        return;
	}
	
	
	@RequestMapping("/device")
	@ResponseBody
	public void handleAllDevice(HttpServletRequest request,HttpServletResponse response) throws IOException, WxErrorException {
		    WxMpService wxMpService = startupConfig.getWxMpService();
		    String signature = request.getParameter("signature");
		    String nonce = request.getParameter("nonce");
		    String timestamp = request.getParameter("timestamp");
		    String echostr = request.getParameter("echostr");
		    if (!wxMpService.checkSignature(timestamp, nonce, signature)) {
		      // 消息签名不正确，说明不是公众平台发过来的消息
		    	logger.info("check false.");
		        response.getWriter().print("非法请求");
		        return;
		    }
		    if (StringUtils.isNotBlank(echostr)) {
		      // 说明是一个仅仅用来验证的请求，回显echostr
		    	logger.info("check true.");
		        response.getWriter().print(echostr);
		        return;
		    }
		    String encryptType = StringUtils.isBlank(request.getParameter("encrypt_type")) ?
		            "raw" : request.getParameter("encrypt_type");
		        if ("raw".equals(encryptType)) {
		          // 明文传输的消息
		          this.wxDeviceRawMessage(request, response);
		          return;
		        }
		        if ("aes".equals(encryptType)) {
		          // 是aes加密的消息
				///String msgSignature = request.getParameter("msg_signature");
				//WxMpXmlMessage inMessage = WxMpXmlMessage.fromEncryptedXml(request.getInputStream(), wxMpConfigStorage, timestamp, nonce, msgSignature);
				//WxMpXmlOutMessage outMessage = wxMpMessageRouter.route(inMessage);
				//response.getWriter().write(outMessage.toEncryptedXml(wxMpConfigStorage));
		          return;
		        }
		        response.getWriter().println("不可识别的加密类型");
		        return;
	}
	
	@GetMapping("/getSysInfo")
	@ResponseBody
	public Map<String, Object> getSysInfo(HttpServletRequest request) throws WxErrorException{
		WxMpService wxMpService = startupConfig.getWxMpService();
		String openId = request.getParameter("openid");
		logger.info("openid from request: " + openId);
		WxJsapiSignature wxSignature = wxMpService.createJsapiSignature("http://live-smart.com.cn/mui/index.html?openid="+openId);
		Map<String, Object> data = new HashMap<String,Object>();
		if(wxSignature != null){
			long timestamp = wxSignature.getTimestamp();
			String noncestr = wxSignature.getNoncestr();
			String signature = wxSignature.getSignature();
			logger.info("timestamp: " + timestamp + ", noncestr: " + noncestr + ", signature: " + signature);
			data.put("timestamp", timestamp);
			data.put("noncestr", noncestr);
			data.put("signature", signature);
		}
		return data;
	}
	
	@GetMapping("/getSysInfoByUrl")
	@ResponseBody
	public Map<String,Object> getSysInfoByUrl(HttpServletRequest request) throws WxErrorException{
		WxMpService wxMpService = startupConfig.getWxMpService();
		String url = request.getParameter("url");
		logger.info("url from request: " + url);
		WxJsapiSignature wxSignature = wxMpService.createJsapiSignature(url);
		Map<String, Object> data = new HashMap<String,Object>();
		if(wxSignature != null){
			long timestamp = wxSignature.getTimestamp();
			String noncestr = wxSignature.getNoncestr();
			String signature = wxSignature.getSignature();
			logger.info("timestamp: " + timestamp + ", noncestr: " + noncestr + ", signature: " + signature);
			data.put("timestamp", timestamp);
			data.put("noncestr", noncestr);
			data.put("signature", signature);
		}
		return data;
	}
	
	
	
	@GetMapping("/getOpenId")
	@ResponseBody
	public Map<String, Object> getOpenId(HttpServletRequest request) throws WxErrorException{
		WxMpService wxMpService = startupConfig.getWxMpService();
		String code = request.getParameter("code");
		logger.info("code from request: " + code);
		WxMpOAuth2AccessToken wxMpOAuth2AccessToken = wxMpService.oauth2getAccessToken(code);
//		WxMpUser wxMpUser = wxMpService.oauth2getUserInfo(wxMpOAuth2AccessToken, null);
		Map<String, Object> data = new HashMap<String,Object>();
		if(wxMpOAuth2AccessToken != null){
			data.put("open_id", wxMpOAuth2AccessToken.getOpenId());
		}
		return data;
	}
	
	
	@RequestMapping("/devicelist")
	@ResponseBody
	public RestResponse getLockList(@RequestParam(required = true) String openId){
		long starttime = new Date().getTime();
		List<Map<String, Object>> result = new ArrayList<Map<String,Object>>();
		List<UserLockTb> locks = userLockService.getLockByOpenId(openId);
		logger.info("openID="+openId+"select lock time :"+(new Date().getTime()-starttime)+"ms");
		if(!CollectionUtils.isEmpty(locks)){
			for(int index = 0;index<locks.size();index++){
				UserLockTb lock  = locks.get(index);
				Map<String, Object> data = new HashMap<String,Object>();
			    List<LockKeyTb> keyList = lockKeyService.findlockkeyByLockId(lock.getLockId(),lock.getOpenId());
				data.put("keyList", keyList);
				data.put("lockId", lock.getLockId());
				data.put("locktb", lock.getLockTb());
				data.put("usertb", lock.getUserTb());
				result.add(data);
			}
		}
		logger.info("time :"+(new Date().getTime()-starttime)+"ms");
	    return RestResponse.build(ResponseCode.SUCCESS, result);
	}
	
	@RequestMapping("/unbindKey")
	@ResponseBody
	public RestResponse unbindKey(@RequestParam(required = true)String ticket,@RequestParam(required = true) String deviceId,@RequestParam(required = true) String openId){
		UserLockKeyBean key = lockKeyService.getKeyByDeviceId(deviceId);
		if(key == null){
			return RestResponse.build(ResponseCode.DEVICE_NOT_EXIST);
		}
		if(!key.getOpenId().equals(openId)){
			return RestResponse.build(ResponseCode.DEVICE_NOT_BIND);
		}
		if(key.getType() == 1){
			//蓝牙管理钥匙
			userLockService.unbindAllLockKey(openId,userLockService.getLockByOpenIdAndDeviceId(openId, deviceId));
		}else{
			lockKeyService.unbindKey(key.getLockId(),key.getKeyId());
		}
		return RestResponse.build(ResponseCode.SUCCESS);
	}
	
	@RequestMapping("/unbindLock")
	@ResponseBody
	public RestResponse unbindLock(@RequestParam(required = true)String ticket,@RequestParam(required = true) String lockId,@RequestParam(required = true) String openId,@RequestParam(required=true) String deviceId){
		if(userLockService.deleteByOpenIdAndLockId(openId, lockId)){
			List<KeyTb> keytbs = lockKeyService.findKeyListByLockId(lockId, 1);
			for (KeyTb keyTb : keytbs) {
				if(keyTb.getType()==1&&keyTb.getDeviceId()!=null){
					int count = lockKeyService.findLockKeyRelationCount(keyTb.getKeyId(),openId);
					if(count==0){
						userLockService.compelUnbindDevice(openId, keyTb.getDeviceId());
					}
					//LockKeyTb lockkey = lockKeyService.findLockKeyByLockIdAndKeyId(lockId, keyTb.getKeyId());
					//lockkey.setIsFlag("0");
					//lockKeyService.updateLockKey(lockkey);
				}
			}
		}
		return RestResponse.build(ResponseCode.SUCCESS);
	}
	
	@RequestMapping("/getKeyId")
	@ResponseBody
	public RestResponse getKeyId(@RequestParam(required = true)String ticketId,@RequestParam(required = true)String lockId){
		KeyTb userLockKeyBean = lockKeyService.getKeyByTicketId(ticketId);
		if(userLockKeyBean.getType() != 1){
			LockKeyTb key = new LockKeyTb();
			key.setLockId(lockId);
			lockKeyService.save(key);
		}
		Map<String, String> data = new HashMap<String,String>();
		data.put("keyID", userLockKeyBean.getKeyId());
		return RestResponse.build(ResponseCode.SUCCESS, data);
	}
	
	@RequestMapping("/getkey")
	@ResponseBody
	public RestResponse getKey(@RequestParam String keyId){
		KeyTb key = lockKeyService.getKeyByKeyId(keyId);
		return RestResponse.build(ResponseCode.SUCCESS, key);
	}
	
	@RequestMapping("/addKey")
	@ResponseBody
	public RestResponse addKey(@RequestParam(required = true)String position,@RequestParam(required = true)String keyId,@RequestParam(required = true)String lockId,@RequestParam String openId,@RequestParam String ticket){
		LockKeyTb lockkey = lockKeyService.findLockKeyByLockIdAndKeyId(lockId, keyId); 
		 if(lockkey==null){
			 lockkey  = new LockKeyTb();
		 }
		KeyTb key = lockKeyService.getKeyByKeyId(keyId);
		if(key.getKeyId()==null){
			//设备不存在  数据表中未添加
			return RestResponse.build(ResponseCode.DEVICE_NOT_EXIST);
		}
		key.setPosition(Integer.parseInt(position));
		key.setState("1");//1启动 2禁止 首次添加 默认启动
		lockkey.setKeyId(keyId);
		lockkey.setLockId(lockId);
		lockkey.setIsFlag("1");
		lockkey.setState("1");
		lockkey.setPosition(Integer.parseInt(position));
		if(lockKeyService.addkey(key,lockkey)){
			if(key.getType() == 1){
				//如果是蓝牙钥匙绑定钥匙
			  if(!userService.checkWxDeviceByOpenId(openId, key.getDeviceId())){
				  userLockService.bindDevice(openId,key.getDeviceId(),ticket);
			  }
			}
		};
		return RestResponse.build(ResponseCode.SUCCESS);
	}
	
	@RequestMapping("/removeKey")
	@ResponseBody
	public RestResponse removeKey(@RequestParam(required = true)String lockId,@RequestParam(required = true)String keyId,@RequestParam String openId){
		List<LockKeyTb> lockKeyTbs = lockKeyService.findLockKeyByKeyId(keyId,openId,lockId);
		 LockKeyTb lockKeyTb = lockKeyTbs.get(0); 
		if(lockKeyTb.getKeyTb() == null){
			return RestResponse.build(ResponseCode.DEVICE_NOT_EXIST);
		}
		//lockKeyService.deleteKey(lockId,keyId); 
		lockKeyTb.setIsFlag("0");//0 为已删除状态  1为可用状态
		if(lockKeyService.updateLockKey(lockKeyTb)>0){
			KeyTb key = lockKeyTb.getKeyTb();
			int count = lockKeyService.findLockKeyRelationCount(keyId,openId);
			if(key!=null&&key.getType()!=null&&key.getType()==1&&count==0){
				userLockService.compelUnbindDevice(openId, key.getDeviceId());
			}
		}
		return RestResponse.build(ResponseCode.SUCCESS);
	}
	
	@RequestMapping("/getKeyInfo")
	@ResponseBody
	public RestResponse getKeyInfo(@RequestParam(required = true)String lockId){
		List<Map<String, String>> data = new ArrayList<Map<String,String>>();
		List<KeyTb> list = lockKeyService.findKeyListByLockId(lockId,0);
		if(!CollectionUtils.isEmpty(list)){
			for(KeyTb key:list){
				Map<String, String> info = new HashMap<String,String>();
				info.put("keyID", key.getKeyId());
				if(key.getDeviceId() != null){
					info.put("device_id", key.getDeviceId());
				}
				info.put("position", String.valueOf(key.getPosition()));
				info.put("type", String.valueOf(key.getType()));
				info.put("status", key.getState());
				data.add(info);
			}
		}
		return RestResponse.build(ResponseCode.SUCCESS, data);
	}
	
	@RequestMapping("/changeKeyStatus")
	@ResponseBody
	public RestResponse changeKeyStatus(@RequestParam(required = true)String keyId,@RequestParam(required = true)String deviceId,@RequestParam(required = true)String keyState,boolean flag,String lockId,String openId){
		List<LockKeyTb> lockKeyTbs = lockKeyService.findLockKeyByKeyId(keyId,openId,lockId);
		KeyTb keyTable = new KeyTb();
		LockKeyTb lockkey = new LockKeyTb();
		if(lockKeyTbs!=null&&lockKeyTbs.get(0)!=null){
			lockkey = lockKeyTbs.get(0);
		}
		if(flag){//禁用或启用自己
			keyTable = lockKeyService.getKeyTbByKeyId(keyId);
			keyTable.setState(keyState);
			lockkey.setState(keyState);
			lockKeyService.updateKey(keyTable);
			lockKeyService.updateLockKey(lockkey);
		}else{
			lockkey.setState(keyState);
			lockKeyService.updateLockKey(lockkey);
		}
		return RestResponse.build(ResponseCode.SUCCESS);
	}
	@RequestMapping("/deviceauth")
	public RestResponse deviceAuth(HttpServletRequest request){
		String postData = request.getParameter("postData");
		JSONObject jsonObject = JSONObject.parseObject(postData);
		System.out.println(jsonObject.getString("deviceId"));
			boolean isok =  lockKeyService.deviceAuth(jsonObject);
			if(isok){
				Map<String,Object> data = new HashMap<String,Object>();
				data.put("device_id",jsonObject.getString("deviceId"));
				return  RestResponse.build(ResponseCode.SUCCESS,data );
			}
			return RestResponse.build(ResponseCode.CONFIG_NOT_EXIST, null);
	}
	
	/**
	 * 微信推送事件处理   订阅  subscribe  已订阅scan   取消订阅unsubscribe
	 * @param request
	 * @param response
	 * @throws IOException
	 * @throws WxErrorException 
	 */
	private void WxRawMessage(HttpServletRequest request,HttpServletResponse response) throws IOException, WxErrorException{
		   // 明文传输的消息
          String body = IOUtils.toString(request.getInputStream(), "UTF-8");
          WxMpXmlMessage inMessage = WxMpXmlMessage.fromXml(body);
          WxMpXmlOutImageMessage text =  WxMpXmlOutMessage.IMAGE().build();
          WxMpService wxMpService = startupConfig.getWxMpService();
          //事件推送
          File  file= ResourceUtils.getFile("classpath:image/xiaowang1.png");
          WxMediaUploadResult wxMediaUploadResult =  wxMpService.mediaUpload("image", file);
           String eventType = inMessage.getEvent();
           if(inMessage.getMsgType().equalsIgnoreCase("event")){
        	   if(eventType.equalsIgnoreCase("subscribe")){
        		   //订阅
        		  text.setMediaId(wxMediaUploadResult.getMediaId());
        	   }else if(eventType.equalsIgnoreCase("SCAN")){
        		   //已订阅
        		   text.setMediaId(wxMediaUploadResult.getMediaId());
        	   }else if(eventType.equalsIgnoreCase("unsubscribe")){
        		   //取消订阅
        		   text.setMediaId(wxMediaUploadResult.getMediaId());
        	   }
           }else{
        	   text.setMediaId(wxMediaUploadResult.getMediaId());
           }
           text.setToUserName(inMessage.getFromUserName());
           text.setMsgType("image");
           text.setCreateTime(inMessage.getCreateTime());
           text.setFromUserName(inMessage.getToUserName());
           logger.debug("text = "+text.toXml());
           logger.debug("body = "+body);
           response.getWriter().write(text.toXml()); 
          return;
	}
	/**
	 * 微信硬件事件推送处理      绑定事件 bind   解绑事件unbind
	 * @param request
	 * @param response
	 * @throws IOException
	 * @throws WxErrorException 
	 */
	private void wxDeviceRawMessage(HttpServletRequest request,HttpServletResponse response) throws IOException, WxErrorException{
		  String body = IOUtils.toString(request.getInputStream(), "UTF-8");
	        WxMpDeviceJsonMessage inMessage = WxMpGsonBuilder.INSTANCE.create().fromJson(body, WxMpDeviceJsonMessage.class);
	        String msgType = inMessage.getMsgType();
	        if("bind".equals(msgType)){
	        	UserTb user=null;
	        	if((user = userService.checkUser(inMessage.getOpenId()))==null){
	        		//检查用户不存在时添加用户
	        		user = new UserTb();
	        		user.setOpenId(inMessage.getOpenId());
	        		user.setUserId(inMessage.getOpenId());
	        		userService.addUser(user);
	        	}
	        	String lockId = inMessage.getQrcodeSuffixData();
	        	//String lockId = this.Base64Decoder(data);
	        	if(lockId!=null&&lockId.startsWith("lock")){
	        		lockId = lockId.substring(lockId.indexOf("lock")+4, lockId.length());
	        		userLockService.compelUnbindDevice(inMessage.getOpenId(),inMessage.getDeviceId());
	        		this.bindLock(inMessage.getOpenId(), lockId);
	        	}else{
	        		//绑定包
	        		List<UserLockTb> locks = userLockService.getLockByOpenIdAndDeviceId(inMessage.getOpenId(), inMessage.getDeviceId());
	        		UserLockTb newLock= null;
	        		if(!locks.isEmpty()&&locks.get(0)!=null){
	        			newLock = locks.get(0);
	        		}else{
	        			newLock=new UserLockTb();
	        			List<Object> locksByDevice =  lockKeyService.findLocksbydeviceId(inMessage.getDeviceId());
	        			newLock.setOpenId(inMessage.getOpenId());
	        			//newLock.setLockId(((LockKeyTb)locksByDevice.get(0)).getLockId());
	        			userLockService.bindDevice(newLock,locksByDevice);
	        		}
	        		KeyTb key = lockKeyService.getKeyTbByDeviceId(inMessage.getDeviceId());
	        		/*LockKeyTb lockkey = lockKeyService.findLockKeyByLockIdAndKeyId(newLock.getLockId(),key.getKeyId());
	        		if(lockkey!=null&&"0".equals(lockkey.getIsFlag())){
	        			//应该还要检查该绑定用户是否拥有恢复已删除蓝牙钥匙的权限
	        			lockkey.setIsFlag("1");
	        			lockKeyService.updateLockKey(lockkey);
	        		}*/
	        	}
				response.getWriter().write(body);
	        } 
	        if("unbind".equals(msgType)){
	        	//用户点击微信设置里的【删除设备】来删除设备
	        	String lockId = inMessage.getQrcodeSuffixData();
	        	if(lockId!=null&&lockId.startsWith("lock")){
	        		return ;
	        	}
	        	List<UserLockTb> locks = userLockService.getLockByOpenIdAndDeviceId(inMessage.getOpenId(), inMessage.getDeviceId());
	        	if(locks.isEmpty()){
	        		return;
	        	}
	        	 userLockService.unbindAllLockKey(inMessage.getOpenId(), locks); 
	        	 response.getWriter().write(body);
	        }
	}
	
	private void bindLock(String openId,String lockId) throws WxErrorException{
		WxMpService wxMpService = startupConfig.getWxMpService();
		String ticket = wxMpService.getJsapiTicket();
		logger.debug("-------------ticket="+ticket);
		List<KeyTb> manageKeys = lockKeyService.findKeyListByLockId(lockId, 1);
	    for(KeyTb key:manageKeys){
		   //如果该用户未绑定 就绑定设备
		   if(key.getType()==1&&!userService.checkWxDeviceByOpenId(openId,key.getDeviceId())){
		       userLockService.compelbindDevice(openId,key.getDeviceId());
			 //  userLockService.bindDevice(openId,key.getDeviceId(), ticket);
	       }
	    }
	    if(userLockService.checkUserLock(openId, lockId)==null){
	    	UserLockTb userlocktb = new UserLockTb();
	    	userlocktb.setLockId(lockId);
	    	userlocktb.setOpenId(openId);
	    	userLockService.bindDevice(userlocktb);
	    }
	}
	
	
	
	@RequestMapping("/updateKey")
	@ResponseBody
	public RestResponse updateKey(@RequestParam String key){
		logger.debug("key="+key);
		JSONObject newKey = JSONObject.parseObject(key);
		KeyTb keytb = new KeyTb(newKey.getInteger("kid"),newKey.getString("keyId"),
								newKey.getString("deviceId"),newKey.getString("keyName"),
								newKey.getInteger("type"),newKey.getInteger("position"),
								GetDateUtils.getDateByStr(newKey.getString("createTime")),newKey.getString("creator"),
								newKey.getString("state"),GetDateUtils.getDateByStr(newKey.getString("bindTime")),
								newKey.getString("toothCode"),newKey.getString("qrcode"),
								newKey.getString("manage"),newKey.getString("note"),
								newKey.getString("version"),newKey.getString("ticketId"),
								newKey.getString("qrcodeSerial"),newKey.getString("mac")
					 );
		
		int i = lockKeyService.updateKey(keytb);
		if(i>0){
			return RestResponse.build(ResponseCode.SUCCESS);
		}
		return null;
	}
	 
	@RequestMapping("/updateLock")
	@ResponseBody
	public RestResponse updateLock(@RequestParam String lock){
		logger.debug("lock="+lock);
		JSONObject 	 lockObj = JSONObject.parseObject(lock);
		LockTb  locktb = new LockTb();
		locktb.setLockId(lockObj.getString("lockId"));
		locktb.setCreateTime(GetDateUtils.getDateByStr(lockObj.getString("createTime")));
		locktb.setLockName(lockObj.getString("lockName"));
		int i = userLockService.updateLock(locktb);
		if(i>0){
			return RestResponse.build(ResponseCode.SUCCESS);
		}
		return null;
	}
}
